#include <Rcpp.h>
#include <vector>
#include "factorial.h"
#include "binomial.h"
#include "integers.h"

using namespace Rcpp;


// [[Rcpp::interfaces(r, cpp)]]
// [[Rcpp::export]]
NumericVector catalan(unsigned int n) {
  std::vector<unsigned long int> x(n);

  x[0] = 1;

  for (unsigned int i = 1; i <= x.size(); i++) {
    x[i] = (2.0 * (2.0 * i + 1.0)) / (i + 2.0) * x[i-1];
  }

  NumericVector x1 = Rcpp::wrap(x);
  return x1;
}


// [[Rcpp::interfaces(r, cpp)]]
// [[Rcpp::export]]
NumericVector cullen(unsigned int n) {
  std::vector<unsigned long int> x(n);

  x[0] = 0;

  for (unsigned int i = 1; i <= x.size(); i++) {
    x[i] = pow(2, i) * i + 1;
  }

  NumericVector x1 = Rcpp::wrap(x);
  return x1[x1 > 0];
}


// [[Rcpp::interfaces(r, cpp)]]
// [[Rcpp::export]]
NumericVector supercatalan(unsigned int n) {
  std::vector<unsigned long int> x(n + 1);
  x[0] = 0.0; x[1] = 1.0; x[2] = 1.0;

  for (int i = 3; i <= x.size(); i++) {
    //x[i] = (3.0 * (2.0 * i - 3.0) * x[i-1] - (i - 3.0) * x[i-2]) / i;
    x[i] = (1.0 / i) * ((6.0 * i - 9.0) * x[i-1] - (i - 3.0) * x[i-2]);
  }

  NumericVector x1 = Rcpp::wrap(x);
  return x1[x1 > 0.0];
}


//' Computes the Fibonacci sequence up to given value of n.
//'
//' The Fibonacci sequence is defined by a recurrence relation where \eqn{f_n}
//' denotes the series up to \eqn{n} points. \deqn{f_n = f_{n-1} + f_{n-2}}
//' With initial coniditions: \deqn{f_1 = 1, \qquad f_2 = 2}
//' @param n Integer designating the stopping point of the Fibonacci sequence
//' @param output If 'last', the last integer in the Fibonacci sequence up to n
//'   is returned, if 'array', the entire sequence is returned. Defaults to
//'   'last'.
//' @return array of the Fibonacci sequence up to \eqn{n}.
//' @examples
//' fibonacci(10)
//' fibonacci(10, 'array')
//' @references Moler, C. (2011). Numerical computing with MATLAB (1st ed.).
//' Philadelphia, Pa: Society for Industrial & Applied Mathematics.
//' @export
// [[Rcpp::interfaces(r, cpp)]]
// [[Rcpp::export]]
NumericVector fibonacci(unsigned long int n) {
  std::vector<unsigned long int> x(n);

  x[0] = 1;
  x[1] = 1;

  for (unsigned int i = 2; i <= x.size(); i++) {
    x[i] = x[i - 1] + x[i - 2];
  }

  NumericVector x1 = Rcpp::wrap(x);
  return x1;
}


//' Computes the famous \eqn{3n + 1} sequence, also known as the Collatz
//' conjecture.
//'
//' The Collatz conjecture, also known as the \eqn{3n + 1} problem, is a
//' currently unsolved problem in number theory that is stated as: Start with a
//' positive integer \eqn{n} If \eqn{n} is even, divide \eqn{n} by 2 If \eqn{n}
//' is odd, multiply by 3 and add 1 to obtain \eqn{3n + 1} Repeat this process
//' until the sequence reaches 1. It is unknown if there is a starting integer
//' \eqn{n} that does not result in the sequence ending with 1.
//'
//' @param n Starting integer to begin \eqn{3n + 1} process
//' @return vector containing sequence generated by the Collatz conjecture. If n
//'   is 1, 1 is returned.
//' @examples
//' three_n_one(7)
//' three_n_one(10)
//' @references 3x + 1 problem. (2017, May 13). In Wikipedia, The Free
//' Encyclopedia. from
//' https://en.wikipedia.org/w/index.php?title=3x_%2B_1_problem&oldid=780191927
//' Moler, C. (2011). Numerical computing with MATLAB (1st ed.). Philadelphia,
//' Pa: Society for Industrial & Applied Mathematics.
//' @export
// [[Rcpp::interfaces(r, cpp)]]
// [[Rcpp::export]]
NumericVector three_n_one(unsigned int n) {
  std::vector<unsigned long int> x(n);

  if (n == 1) {
    x.resize(1);
    x[0] = 1;
    NumericVector x1 = Rcpp::wrap(x);
    return x1;
  }

  unsigned int i = 0;

  do {
    if (_iseven(n) == true) {
      n = n / 2;
    }
    else {
      n = 3 * n + 1;
    }

    x[i] = n;
    i = i + 1;

    if (i > x.size()) {
      x.resize(i + 1);
    }

  } while (n > 1);

  if (x.size() >= i) {
    x.resize(i);
  }

  NumericVector x1 = Rcpp::wrap(x);
  return x1;
}
