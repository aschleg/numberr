# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Calculates the binomial coefficient using a recursive method.
#'
#' The recursive method of the binomial coefficient calculation is defined as:
#' \deqn{\binom{n}{k} = \binom{n - 1}{n - k} + binom{n - 1}{k} \qquad for n, k:
#' 1 \leq k \leq n - 1} With boundary values: \deqn{\binom{n}{0} = \binom{n}{n}
#' = 1}
#' @param n Number of possibilities
#' @param k number of unordered outcomes
#' @return The binomial coefficient
#' @references Binomial coefficient. (2017, April 17). In Wikipedia, The Free
#'   Encyclopedia. From
#'   https://en.wikipedia.org/w/index.php?title=Binomial_coefficient&oldid=775905810
#'    Binomial coefficients. Encyclopedia of Mathematics. From
#'   http://www.encyclopediaofmath.org/index.php?title=Binomial_coefficients&oldid=39155
#'    Weisstein, Eric W. "Binomial Coefficient." From MathWorld--A Wolfram Web
#'   Resource. http://mathworld.wolfram.com/BinomialCoefficient.html
#' @export
binomial_recursive <- function(n, k) {
    .Call('numberr_binomial_recursive', PACKAGE = 'numberr', n, k)
}

#' Calculates the binomial coefficient using the multiplicative equation.
#'
#' The multiplicative method for computing the binomial coefficient is more
#' efficient than the compact form calculation and is defined as:
#' \deqn{\binom{n}{k} = \frac{n(n-1)(n-2) \cdots (n-(k-1))}{k(k-1)(k-2) \cdots
#' 1} = \prod^k_{i=1} \frac{n + 1 - i}{i}}
#'
#' @param n Number of possibilities
#' @param k number of unordered outcomes
#' @return The binomial coefficient
#' @examples
#' binomial.coefficient.multiplicative(10, 5)
#' binomial.coefficient.multiplicative(20, 10)
#' @references Binomial coefficient. (2017, April 17). In Wikipedia, The Free
#'   Encyclopedia. From
#'   https://en.wikipedia.org/w/index.php?title=Binomial_coefficient&oldid=775905810
#'    Binomial coefficients. Encyclopedia of Mathematics. From
#'   http://www.encyclopediaofmath.org/index.php?title=Binomial_coefficients&oldid=39155
#'    Weisstein, Eric W. "Binomial Coefficient." From MathWorld--A Wolfram Web
#'   Resource. http://mathworld.wolfram.com/BinomialCoefficient.html
#' @export
binomial_multiplicative <- function(n, k) {
    .Call('numberr_binomial_multiplicative', PACKAGE = 'numberr', n, k)
}

#' Calculates the binomial coefficient using the factorial method.
#'
#' The binomial coefficient equation (in compact form) is defined as:
#' \deqn{\binom{n}{k} = \frac{n!}{k!(n-k)!} \qquad 0 \leq k \leq n}
#' @param n Number of possibilities
#' @param k number of unordered outcomes
#' @return The binomial coefficient
#' @references Binomial coefficient. (2017, April 17). In Wikipedia, The Free
#'   Encyclopedia. From
#'   https://en.wikipedia.org/w/index.php?title=Binomial_coefficient&oldid=775905810
#'    Binomial coefficients. Encyclopedia of Mathematics. From
#'   http://www.encyclopediaofmath.org/index.php?title=Binomial_coefficients&oldid=39155
#'    Weisstein, Eric W. "Binomial Coefficient." From MathWorld--A Wolfram Web
#'   Resource. http://mathworld.wolfram.com/BinomialCoefficient.html
#' @export
binomial_factorial <- function(n, k) {
    .Call('numberr_binomial_factorial', PACKAGE = 'numberr', n, k)
}

#' Computes the factorization of an integer \eqn{n} by Fermat's factorization
#' method.
#'
#' Fermat's factorization theorem redefines a composite number \eqn{n} as the
#' difference of squares: \deqn{n = a^2 - b^2} Which can also be written as:
#' \deqn{n = (a + b)(a - b)}
#'
#' @param n Integer to be factored into product of smaller integers.
#' @examples
#' fermat(9)
#' fermat(13742)
#' fermat(17)
#' @references Barnes, C. (2004). Integer Factorization Algorithms (1st ed.).
#'   Corvallis, OR: Department of Physics, Oregon State University. Fermat's
#'   factorization method. (2017, January 31). In Wikipedia, The Free
#'   Encyclopedia. From
#'   https://en.wikipedia.org/w/index.php?title=Fermat%27s_factorization_method&oldid=763010603
#' @export
fermat <- function(n) {
    .Call('numberr_fermat', PACKAGE = 'numberr', n)
}

#' Implementation of Pollard's rho algorithm for factorizing an
#' integer \eqn{n} into two non-trivial prime numbers.
#'
#' @param n Integer to be factored into product of smaller integers.
#' @return Vector containing the two prime factors of \eqn{n}, should they exist.
#' @examples
#' pollardrho(9)
#' pollardrho(18364)
#' pollardrho(13)
#' @references Barnes, C. (2004). Integer Factorization Algorithms (1st ed.).
#'   Corvallis, OR: Department of Physics, Oregon State University. Fermat's
#'   factorization method. (2017, January 31). In Wikipedia, The Free
#'   Encyclopedia. From
#'   https://en.wikipedia.org/w/index.php?title=Fermat%27s_factorization_method&oldid=763010603
#' @export
pollardrho <- function(n) {
    .Call('numberr_pollardrho', PACKAGE = 'numberr', n)
}

#' Function for calculating factorials using the standard approach as explained
#' below.
#'
#' Factorials are denoted for a positive integer \eqn{x} as \eqn{x!} and are
#' defined as: \deqn{x! = (x)(x - 1)(x - 2) \cdots (2)(1)} For example, the
#' factorial of 5 is written as: 5! = (5)(4)(3)(2)(1) = 120
#'
#' @param n Desired integer to compute factorial
#' @examples
#' factorial(10)
#' factorial(50)
#' @references Press, W., Teukolsky, S., Vetterling, W., & Flannery, B. (2007).
#'   Numerical recipes (3rd ed.). Cambridge: Cambridge University Press.
#'   Weisstein, Eric W. "Factorial." From MathWorld--A Wolfram Web Resource.
#'   http://mathworld.wolfram.com/Factorial.html
factorial <- function(n) {
    .Call('numberr_factorial', PACKAGE = 'numberr', n)
}

#' Approximates a factorial of an integer \eqn{n} using Stirling's
#' Approximation. Specifically, the approximation is done using a method
#' developed by Gosper.
#'
#' Stirling's approximation is a method of approximating a factorial \eqn{n!}.
#' As the value of \eqn{n} increases, the more exact the approximation becomes;
#' however, it still yields almost exact results for small values of \eqn{n}.
#' The approximation used is given by Gosper, which is noted to be a better
#' approximation to \eqn{n!} and also results in a very close approximation to
#' \eqn{0! = 1}. \deqn{n! \approx \sqrt{(2n + \frac{1}{3})\pi} n^n e^{-n}}
#'
#' @param n desired integer to approximate factorial
#' @examples
#' stirling(0)
#' stirling(5)
#' stirling(50)
#' @references Stirling's approximation. (2017, March 8). In Wikipedia, The
#'   Free Encyclopedia. From
#'   https://en.wikipedia.org/w/index.php?title=Stirling%27s_approximation&oldid=769328178
#'    Weisstein, Eric W. "Stirling's Approximation." From MathWorld--A Wolfram
#'   Web Resource. http://mathworld.wolfram.com/StirlingsApproximation.html
stirling <- function(n) {
    .Call('numberr_stirling', PACKAGE = 'numberr', n)
}

#' Approximates the factorial of n using the approximation given by Ramanujan
#' in his lost notebook (Ramanujan 1988, as cited in Wikipedia). Computing the
#' factorial in logarithmic form is useful as it helps avoid overflow when n is
#' large. As values of n increase, the approximation given becomes more exact.
#'
#' It is often useful to compute the logarithmic form of the factorial and
#' convert it to exponent form to avoid overflow. The approximation is an
#' alternative approach given by Srinivasa Ramanujan (Ramanujan 1988). \deqn{ln
#' n! \approx n ln n - n + \frac{1}{6} ln(n(1 + 4n(1 + 2n))) + \frac{1}{2} ln
#' \pi}
#'
#' @param n desired integer to approximate factorial
#' @examples
#' stirlingln(50)
#' stirlingln(10)
#' @references Stirling's approximation. (2017, March 8). In Wikipedia, The
#'   Free Encyclopedia. From
#'   https://en.wikipedia.org/w/index.php?title=Stirling%27s_approximation&oldid=769328178
#' @export
stirlingln <- function(n) {
    .Call('numberr_stirlingln', PACKAGE = 'numberr', n)
}

#' Approximates the factorial :math:`n!` given an integer :math:`n` using
#' Ramanujan's formula. Ramanujan's formula is just as or more accurate than
#' several other factorial approximation formulas.
#'
#' Ramanujan's formula is another factorial approximation method known for its
#' accuracy in comparison to other factorial approximation approaches including
#' Stirling's and Gosper's approximations. Ramanujan's formula is defined as:
#' \deqn{n! \approx \sqrt{\pi} \left(\frac{n}{e}\right)^n \sqrt[6]{8n^3 + 4n^2
#' + n + \frac{1}{30}}}
#'
#' @param n integer to approximate factorial
#' @examples
#' ramanujan(10)
#' ramanujan(1)
#' ramanujan(5)
#' @references Mortici, Cristinel. On Gosper's Formula for the Gamma Function.
#'   Valahia University of Targoviste, Department of Mathematics. Retrieved
#'   from http://files.ele-math.com/articles/jmi-05-53.pdf
#' @export
ramanujan <- function(n) {
    .Call('numberr_ramanujan', PACKAGE = 'numberr', n)
}

#' Computes the falling factorial The falling factorial, denoted as
#' \eqn{(x)_{n}} (or \eqn{x^{\underline{n}}}) is defined as the following:
#' \deqn{(x)_n = x(x - 1) \cdots (x - (n - 1))} The first few falling
#' factorials are then: \deqn{(x)_0 = 1} \deqn{(x)_1 = x} \deqn{(x)_2 = x(x -
#' 1)} \deqn{(x)_3 = x(x - 1)(x - 2)} \deqn{(x)_4 = x(x - 1)(x - 2)(x - 3)}
#'
#' @param x integer
#' @param n integer
#' @examples
#' fallingfactorial(10, 5)
#' fallingfactorial(10, 6)
#' fallingfactorial(5, 3)
#' @references Falling and rising factorials. (2017, June 8). In Wikipedia, The
#'   Free Encyclopedia. From
#'   https://en.wikipedia.org/w/index.php?title=Falling_and_rising_factorials&oldid=784512036
#'    Weisstein, Eric W. "Falling Factorial." From MathWorld--A Wolfram Web
#'   Resource. http://mathworld.wolfram.com/FallingFactorial.html
#' @export
fallingfactorial <- function(x, n) {
    .Call('numberr_fallingfactorial', PACKAGE = 'numberr', x, n)
}

fallingfactorial_function <- function(x, n) {
    .Call('numberr_fallingfactorial_function', PACKAGE = 'numberr', x, n)
}

#' Computes the rising factorial. Also known as the Pochhammer symbol.
#'
#' The rising factorial, \eqn{x^{(n)}} (sometimes denoted \eqn{\langle x
#' \rangle_n}) is also known as the Pochhammer symbol in other areas of
#' mathematics. The rising factorial is related to the gamma function
#' \eqn{\Gamma (z)}. \deqn{x^{(n)} \equiv \frac{\Gamma (x + n)}{\Gamma (n)}}
#' where \eqn{x^(0) = 1}. The rising factorial is related to the falling
#' factorial by: \deqn{x^{(n)} = (-x)_n (-1)^n}
#'
#' @param x
#' @param n
#' @examples
#' risingfactorial(10, 6)
#' risingfactorial(5, 3)
#' risingfactorial(15, 10)
#' @references Falling and rising factorials. (2017, June 8). In Wikipedia, The
#'   Free Encyclopedia. From
#'   https://en.wikipedia.org/w/index.php?title=Falling_and_rising_factorials&oldid=784512036
#'    Weisstein, Eric W. "Rising Factorial." From MathWorld--A Wolfram Web
#'   Resource. http://mathworld.wolfram.com/RisingFactorial.html
#' @export
risingfactorial <- function(x, n) {
    .Call('numberr_risingfactorial', PACKAGE = 'numberr', x, n)
}

risingfactorial_function <- function(x, n) {
    .Call('numberr_risingfactorial_function', PACKAGE = 'numberr', x, n)
}

fibonacci <- function(n) {
    .Call('numberr_fibonacci', PACKAGE = 'numberr', n)
}

#' Calculates the Greatest Common Divisor of two integers using the recursive
#' Euclidean algorithm
#'
#' The recursive implementation of the greatest common divisor algorithm was
#' described in the Elements of Euclid but may even predate that.
#' @param a First integer
#' @param b Second integer
#' @return The greatest common divisor
#' @examples
#' gcd_recursive(24, 30)
#' gcd_recursive(9, 5)
#' @references Cormen, T., Leiserson, C., Rivest, R., & Stein, C. (2009).
#'   Introduction to algorithms (3rd ed., pp. 928-930, 934-935). Cambridge
#'   (Inglaterra): Mit Press. Euclidean algorithm. (2017, May 18). In Wikipedia,
#'   The Free Encyclopedia. From
#'   https://en.wikipedia.org/w/index.php?title=Euclidean_algorithm&oldid=780973502
#' @export
gcd_recursive <- function(a, b) {
    .Call('numberr_gcd_recursive', PACKAGE = 'numberr', a, b)
}

#' Calculates the Greatest Common Divisor using the Euclidean division
#' algorithm.
#'
#' The Euclidean division implementation of the greatest common divisor
#' algorithm computes a quotient \eqn{q_k} and a remainder \eqn{r_k} at each
#' step \eqn{k} from the two numbers \eqn{a} and \eqn{b}. The quotient component
#' of Euclidean division is not used in the algorithm, thus only modulo
#' operations are required as that only returns the remainder.
#' @param a First integer
#' @param b Second integer
#' @return The greatest common divisor
#' @examples
#' gcd_division(24, 30)
#' gcd_division(9, 5)
#' gcd_division(193752, 234574)
#' @references Cormen, T., Leiserson, C., Rivest, R., & Stein, C. (2009).
#'   Introduction to algorithms (3rd ed., pp. 928-930). Cambridge (Inglaterra):
#'   Mit Press. Euclidean algorithm. (2017, May 18). In Wikipedia, The Free
#'   Encyclopedia. From
#'   https://en.wikipedia.org/w/index.php?title=Euclidean_algorithm&oldid=780973502
#'    Euclidean division. (2017, May 10). In Wikipedia, The Free Encyclopedia.
#'   From
#'   https://en.wikipedia.org/w/index.php?title=Euclidean_division&oldid=779699188
#' @export
gcd_division <- function(a, b) {
    .Call('numberr_gcd_division', PACKAGE = 'numberr', a, b)
}

#' Computes the Greatest Common Divisor of two integers using the Euclidean subtraction algorithm.
#'
#' Computes the greatest common divisor using the original implementation of the algorithm by
#' Euclid. In this version of the algorithm, the quotient \eqn{q_k} and remainder \eqn{r_k}
#' is calculated by repeated division by subtraction. Therefore, in this implementation of the
#' greatest common divisor algorithm, the modulo operation in the division implementation is
#' replaced by division by repeated subtraction.
#'
#' @param a First integer
#' @param b Second integer
#' @return The greatest common divisor
#' @examples
#' gcd_subtraction(24, 30)
#' gcd_subtraction(9, 5)
#' gcd_subtraction(135614, 234562)
#' @export
gcd_subtraction <- function(a, b) {
    .Call('numberr_gcd_subtraction', PACKAGE = 'numberr', a, b)
}

#' Implementation of the extended form of the Euclidean algorithm which computes
#' the greatest common divisor \eqn{d} and integers \eqn{x} and \eqn{y} such
#' that \eqn{ax + by = d}.
#'
#' The extended Euclidean algorithm computes the greatest common divisor,
#' \eqn{d} of two integers \eqn{a} and \eqn{b} as well as the coefficients
#' \eqn{x} and \eqn{y} such that: \deqn{d = gcd(a, b) = ax + by} The
#' coefficients \eqn{x} and \eqn{y} are known as Bezout's coefficients and can
#' be zero or negative.
#'
#' @param a First integer
#' @param b Second integer
#' @examples
#' gcd.extended(99, 78)
#' @references Bezout's identity. (2017, May 12). In Wikipedia, The Free
#' Encyclopedia. From
#' https://en.wikipedia.org/w/index.php?title=B%C3%A9zout%27s_identity&oldid=780050687
#' Cormen, T., Leiserson, C., Rivest, R., & Stein, C. (2009). Introduction to
#' algorithms (3rd ed., pp. 937-938). Cambridge (Inglaterra): Mit Press.
#' @export
gcd_extended <- function(a, b) {
    .Call('numberr_gcd_extended', PACKAGE = 'numberr', a, b)
}

#' Tests whether a given value \eqn{n} is composite. Essentially the opposite of
#' the isprime() function.
#'
#' A composite number is defined as a positive integer :math:`n` that has a
#' factor than 1 and itself. In short, a composite number is not prime.
#'
#' @param n Value to test
#' @return TRUE if n is composite, FALSE otherwise
#' @examples
#' iscomposite(9)
#' iscomposite(3)
#' iscomposite(10927)
#' @references Weisstein, Eric W. "Composite Number." From MathWorld--A Wolfram
#' Web Resource. http://mathworld.wolfram.com/CompositeNumber.html
#' @export
iscomposite <- function(n) {
    .Call('numberr_iscomposite', PACKAGE = 'numberr', n)
}

#' Tests if two integers are coprime.
#'
#' Two integers \eqn{a} and \eqn{b} are said to be relatively prime (also called
#' relatively prime) if they share no positive divisors except 1.
#'
#' @param a First integer
#' @param b Second integer
#' @return TRUE if given integers are coprime, FALSE otherwise
#' @examples
#' iscoprime(2, 4)
#' iscoprime(2, 3)
#' @references Cormen, T., Leiserson, C., Rivest, R., & Stein, C. (2009).
#' Introduction to algorithms (3rd ed., pp. 931). Cambridge (Inglaterra): Mit
#' Press. Weisstein, Eric W. "Relatively Prime." From MathWorld--A Wolfram Web
#' Resource. http://mathworld.wolfram.com/RelativelyPrime.html
#' @export
iscoprime <- function(a, b) {
    .Call('numberr_iscoprime', PACKAGE = 'numberr', a, b)
}

#' Tests if a given value \eqn{n} is even or not.
#'
#' An even number is defined as an integer with the form \eqn{n = 2k} where
#' \eqn{k} is also an integer. Put differently, an even number is not odd and is
#' thus evenly divisible by 2.
#'
#' @param n Value to test
#' @return TRUE if n is even, FALSE otherwise
#' @examples
#' iseven(5)
#' iseven(4)
#' iseven(4.23)
#' @references Weisstein, Eric W. "Even Number." From MathWorld--A Wolfram Web
#' Resource. http://mathworld.wolfram.com/EvenNumber.html
#' @export
iseven <- function(n) {
    .Call('numberr_iseven', PACKAGE = 'numberr', n)
}

#' Tests whether a given given value n is odd.
#'
#' An odd number is an integer that has the form \eqn{n = 2k + 1} for an integer
#' \eqn{k}. In other words, an odd number is an integer that is not evenly
#' divisible by 2.
#'
#' @param n Value to test
#' @return TRUE if n is odd, FALSE otherwise
#' @examples
#' isodd(5)
#' isodd(4)
#' isodd(5.25)
#' @references Weisstein, Eric W. "Odd Number." From MathWorld--A Wolfram Web
#'   Resource. http://mathworld.wolfram.com/OddNumber.html
#' @export
isodd <- function(n) {
    .Call('numberr_isodd', PACKAGE = 'numberr', n)
}

#' Tests if a given integer is a square number.
#'
#' A square number is an integer that is the square of an integer.
#'
#' @param n Value to test
#' @return TRUE if value is a square number, FALSE otherwise
#' @examples
#' issquare(25)
#' issquare(9)
#' issquare(3)
#' @references Barnes, C. (2004). Integer Factorization Algorithms (1st ed.).
#' Corvallis, OR: Department of Physics, Oregon State University.
#' @export
issquare <- function(n) {
    .Call('numberr_issquare', PACKAGE = 'numberr', n)
}

#' Tests whether a given value n is prime
#'
#' A prime number is defined as a positive integer, \eqn{n > 1} that has no
#' positive divisors other than 1 and itself.
#'
#' @param n Value to test
#' @return TRUE if n is prime, FALSE otherwise
#' @examples
#' isprime(9)
#' isprime(3)
#' isprime(10927)
#' @references Weisstein, Eric W. "Prime Number." From MathWorld--A Wolfram Web
#' Resource. http://mathworld.wolfram.com/PrimeNumber.html
#' @export
isprime <- function(n) {
    .Call('numberr_isprime', PACKAGE = 'numberr', n)
}

lucas_lehmer <- function(n) {
    .Call('numberr_lucas_lehmer', PACKAGE = 'numberr', n)
}

# Register entry points for exported C++ functions
methods::setLoadAction(function(ns) {
    .Call('numberr_RcppExport_registerCCallable', PACKAGE = 'numberr')
})
